git init

git clone

	note: cloning a repository just means to make a copy of one. This can either be done from github to your local machine, or you can even clone a local directory into another local area. Git automatically sets up a remote pointing to the repository you cloned from

	forking: only makes sense in the context of GitHub (or similar tools) in which the site makes a clone of a repository, but references original repository to save space and makes it easier to suggest changes for the original repository

	To add others as collaborators to your repository on GitHub, go to settings -> collaborators and then adding their GitHub username

git clone url name_of_local_repo

git checkout

	note: git checkout shapes your working copy by checking out things from the (local) git repository, but it's a Swiss knife, and can do lots of things, including discarding changes you did (so use it wisely). It mostly serves the purpose of switching to other branches, but also to undo changes to your working copy w.r.t the current branch.

	Also, note that when moving to another branch, if the target branch has a different content for a modified file, you will be prevented from moving to the other branch (and will need to checkout or commit your changes first)

	TODO: 'git co branch' seems to both switch to a new branch and set up the branch to track the remote branch of the same name

git checkout master
git checkout -b new_branch_name

	note: Equivalent to 'git branch new_branch_name' followed by 'git checkout new_branch_name'. Since these are the commands you would use to make and switch to a new branch, it's nice that there is a one line version. This is also the command you would run if you were in a detached head state, made a new commit, and wanted to retain changes

git checkout -b new_branch_name origin/master
	new_branch_name is set to track origin/master

git checkout path

	note: moves your working copy to represent the state of the current branch (also HEAD). This use of checkout WILL delete any changes you may have locally (under that path)

	git checkout my-new-feature
	git checkout .
	-will move to the my-new-feature branch and delete any changes made to the working copy

git log
git log --stat

	note: stat option shows which files were changed in each commit

git log --graph --oneline master branch_from_master
git log -n1

	note: -n1 only shows most recent commit

git log --oneline -5 --author dshope --before "Wed Jan 25 2017"

git status

git diff
git diff --staged
git diff commitID_1 commitID_2
git diff path

git show commitID1

	note: compares given commit to its parent commit

git add

	moves changes from the working directory to the Git staging area. The staging area is where you prepare a snapshot of a set of changes before committing them to the official history (in local directory)

git commit
git commit -m "commit message"
git commit --amend
	change the current commit

git branch
git branch new_branch_name
git branch new_branch_name BranchoffHash
git branch -d coins

	note: deleting a branch only deletes the label. Of course if the deleted branch hasn't been merged with another, the commits starting from the branch point will be effectively lost.

git branch -av

	note: to display the known branches, local and remote (from -a) and with the hash they point to (with -v)

git branch -f master HEAD~3
	forces master to point to the commit which is 3 before the currently checked out commit

git branch -u origin/master foo
	sets the foo branch to track origin/master. If foo is currently checked out, you can even leave it off the end

git remote

	note: like branch command, but for viewing remotes (a remote in the local repository is basically a reference to another repository)

git remote add origin git@github.com:dshope11/reflections.git

	note: to add remote repositories

git remote -v

	note: v for verbose (to show urls), also available for branch command

git remote rm remote_URL

git push origin master

	git push <remote> <place>
	note: push optionally takes two arguments - the remote you want to send changes to and the name of the local branch you'd like to push (by default, branch on remote will have the same name as branch pushed). Also, while this command updates the local repository, it also updates the local branch to point to the new commit if it is the one currently checked out.

	this command translates to this in English:

	Go to the branch named "master" in my repository, grab all the commits, and then go to the branch "master" on the remote named "origin." Place whatever commits are missing on that branch and then tell me when you're done.

	By specifying master as the "place" argument, we told git where the commits will come from and where the commits will go. It's essentially the "place" or "location" to synchronize between the two repositories.

	Keep in mind that since we told git everything it needs to know (by specifying both arguments), it totally ignores where we are checked out!

	also, more advanced:
	git push origin <source>:<destination>
	e.g.
	git push origin foo:bar
		Allows you to specify the foo source branch to get pushed to the bar destination on origin (even if bar doesn't exist on the remote, git will create it automatically)
		<source>:<destination> is commonly refered to as a colon refspec (fancy name for a location that git can figure out, like the branch foo or even just HEAD~1

	also, there exists the concept of pushing "nothing" to a remote branch by not specifying a source:
		git push origin :foo
	This actually deletes the foo branch on the remote! (kind of makes sense)

git push --set-upstream origin master

	note: these options allow remote origin's master branch to be assigned as the upstream branch to the local master branch (-u option also works)

	you can think of git push as publishing your work!

git fetch

	downloads the commits that the remote has but are missing from our local repository, and
	updates where our remote branches point (for instance, origin/master)
	-essentially brings our local representation of the remote repository into synchronization with what the actual remote repository looks like (right now).
	-git fetch, however, does not change anything about your local state. It will not update your master branch or change anything about how your file system looks right now (that's what git pull is for!)
	-think of git fetch as a download step

git fetch origin

	also, more advanced:
	git fetch origin <source>:<destination> works as well, but not commonly used. Here, source is on remote and destination is local (remote branches don't get updated since you specified a destination for the fetch. Not often used, because in the default case the destination is just the remote branch stored locally (and it gets updated, which is usually what you want)

	fetching "nothing" to a place locally actually makes a new branch

git pull --all

	command to pull all changes

git pull origin master

	note: what actually happens with a git pull is that the remote branch gets fetched (updating the local copy of the remote branch) then that branch gets merged into the local one

	or

	'git pull origin master' = 'git fetch origin; git merge master origin/master;''
	
	also,
	'git pull --rebase' = 'git fetch; git rebase;'

	Try and only make changes to origin/master via pull requests so that everyone can see the changes!
	also, TODO: try and implement continuous integration with QFramework by running tests automatically!

	also, more advanced:
	with refspec known for fetch and push, pull is just the following:
	
		'git pull origin foo' = 'git fetch origin foo; git merge o/foo'

		and

		'git pull origin bar~1:bugFix' = 'git fetch origin bar~1:bugFix; git merge bugFix'

git merge branch2 branch3
git merge --abort

	note: git merge will also include the currently checked-out branch in the merged version. So if you have branch1 checked out, and you run git merge branch2 branch3, the merged version will combine branch1 as well as branch2 and branch3. That’s because the branch1 label will update after you make the merge commit, so it’s unlikely that you didn’t want the changes from branch1 included in the merge. For this reason, you should always checkout one of the two branches you’re planning on merging before doing the merge. Which one you should check out depends on which branch label you want to point to the new commit.

	Since the checked-out branch is always included in the merge, you may have guessed that when you are merging two branches, you don't need to specify both of them as arguments to git merge on the command line. If you want to merge branch2 into branch1, you can simply git checkout branch1 and then type git merge branch2. The only reason to type git merge branch1 branch2 is if it helps you keep better mental track of which branches you are merging.

	Also, since the two branches are merged, the order in which they are typed into the command line does not matter. The key is to remember that git merge always merges all the specified branches into the currently checked out branch, creating a new commit for that branch.

git config --list
	To see that user name and email are set properly

git config --global user.name "David Shope"
git config --global user.email "your_email@example.com"
git config --global core.editor "subl -n -w"

*important!
git config --global push.default upstream

git config --global merge.conflictstyle diff3

git config --global push.default simple
	make some operations more straightforward

git config --global http.postBuffer 209715200
	work around an error when adding big files to git

To create git aliases:
	git config --global alias.co checkout

	Now, in ~/.gitconfig,
	[alias]
		co = checkout

git credential-osxkeychain

	note: use to see if osxkeychain is already installed. For Mac only!

git config --global credential.helper osxkeychain

	note: to tell git to use osxkeychain helper to remember your password when talking with GitHub

# Enable tab completion in git
source ~/git-completion.bash

# Change command prompt
source ~/git-prompt.sh
export GIT_PS1_SHOWDIRTYSTATE=1
# '\$(__git_ps1)' adds git-related stuff

lightgrey="\[\033[0;37m\]"
white="\[\033[1;37m\]"
reset="\[\033[0m\]"
export PS1="$lightgrey[\u@\h$white\$(__git_ps1) $lightgrey\W]\$ $reset"

############################
## ASG Git Tutorial Notes ##

-git uses 160-bit (SHA-1) hashes to point to a given state of your repository
-even if from different repositories, a given hash points to the same content

-local repo is located under a folder named .git in your working copy

-HEAD is a reference to the hash describing the current status

-master is a branch (also a reference) that is canonically used to refer to the main branch (like the trunk in SVN)

-kerberos works from lxplus

Recipe for keeping your fork of the atlas offline repo up-to-date:
git rebase upstream/master
git status
git push origin

	Note: ideally you only need to fetch and use upstream/branch, but if you want to update your fork, you can use the above procedure, or in case you know you haven't done new development on your branch (but the upstream side has), you can run git merge upstream/master

git rebase

	note: to replay your local changes on top of another hash and update the current branch pointer to that state

git rebase -i HEAD~4

	Opens an interactive rebase window to rebase while choosing the order of commits and even whether to combine or remove commits

About interacting with remote git repos:
	local and remote branch references do not always match: e.g., if somebody committed to upstream/master and you run git fetch, your local master will differ from your upstream/master reference (before the fetch they would have been the same)

	It is therefore important to use fetch often (there's no harm), and use references with the explicit remote if you intend to use that state (and not rely on whether you updated your local pointer or not)

git reset hash
	to reset the current working directory to a given hash, preserving the changes one made (unless using the --hard option)
	provides a way of undoing a commit
	hash~N is a reference to the Nth parent of a hash (or reference)

git stash
	to interact with the stash, a place to temporarily save your changes away (cleaning up your working copy)
	This is an alternative to committing or checking out changes
git stash list
	to list available stashes
git stash pop
	to replay the changes in your stash on top of your HEAD (and delete the stash)
	Note: you may have to resolve conflicts when you pop the stash if you've drifted too far away from the branch where the stash was saved

git cherry-pick hash
	to apply a commit on top of your current branch
	Note: there is now a new commit hash corresponding to a new commit (different parent and different time) since the state is different (thus different hashes)

######################
## git commit notes ##
http://chris.beams.io/posts/git-commit/

.mailmap file

A git commit message should always be able to complete the following sentence:
If applied, this commit will ___

The seven rules of a great git commit message
	1. Separate subject from body with a blank line
	2. Limit the subject line to 50 characters
	3. Capitalize the subject line
	4. Do not end the subject line with a period
	5. Use the imperative mood in the subject line
	6. Wrap the body at 72 characters
	7. Use the body to explain what and why vs. how

############################################
## Notes from ATLAS git workflow tutorial ##
https://atlassoftwaredocs.web.cern.ch/gittutorial/

Current shell environment setup:
	ssh lxplus
	setupATLAS
	lsetup git
	asetup AtlasExternals,21.0.9
	source /afs/cern.ch/atlas/software/builds/nightlies/Athena-21.0.X-VAL/Athena/rel_1/InstallArea/x86_64-slc6-gcc49-opt/setup.sh

	note: Athena-21.0.X-VAL doesn't currently exist!

for CI of aogt8, must give atlasbot access as Developer to your project:
	Project Settings -> Members

.gitignore:

	# Ignore the most common extra files that can
	# be produced while developing
	*~
	*.sw?
	#*
	.DS_Store
	.pydevproject
	.project
	*.pyc

'lsetup git' is needed to set up a more recent version of git so that the push.default simple is recognized
	Also, to get the git prompt info to work, lsetup git is needed as well!

Full checkout: gives you access to working copies of all files. Very much the standard way of doing things

Sparse checkout: gives you only the parts of the repository you want to update. ('git atlas' wrapper is provided to make this easier)
	clones a copy of remote as a sparse checkout of the master branch (but you'll still have a complete copy of the repository inside the local repo .git)

	https://atlassoftwaredocs.web.cern.ch/gittutorial/git-atlas/ for more info

Sparse build:
	After setting up AtlasExternals as a baseline athena release from the tutorial start, if you ran the normal cmake; make cycle you would rebuild the entire offline release.
	This would take a long time and it's almost certainly not what you want. instead you only want to rebuild part of the release. alternatively,

	mkdir ../build && cd ../build
	cp ../aogt8/Projects/AthenaWorkDir/package_filters.txt .
	EDITOR package_filters.txt
	cmake -DATLAS_PACKAGE_FILTER_FILE=package_filters.txt ../aogt8/Projects/AthenaWorkDir
	make -j

	(maybe put package_filters.txt in a directory outside build so that you can rm -rf * your build area, just not in the git repo so thaty you don't commit it by mistake)


##################################
## Notes from learngitbranching ##
http://learngitbranching.js.org/

Branches are extremely lightweight in git - they are just pointers to a specific commit, nothing more! When you create a new branch, all git needs to do is create a new pointer - it doesn't create a whole new set of folders or files
(no storage, memory overhead)
	hence the mantra "branch early, branch often"

HEAD is just a symbolic name that stands for the commit that is currently checked out

master^ is the parent of master
master^^ is the grandparent of master
	Travel back in time with HEAD^!

	an argument after ^ will specify which parent commit to trace back to (e.g. simple merge commits have 2 parents, so git checkout HEAD^2 would checkout the commit that just got merged)

	you can even chain ~ and ^ together: starting at C7, 'git checkout HEAD~^2~2'would take you to c1 in the following diagram:

	C0		C1
	|		|
	|		|
	C2 		C3
	|		|
	|		|
	C4		C5
	|     /
	|   /
	C6
	|
	|
	C7 *


git revert
	allows you to reverse changes made by a commit but share it with others in a safe way by creating a new commit with the reverse applied. (git reset accomplishes this similarly, but rewrites history)

git tag tagName Hash

	Branches are easily mutated, often temporary, and always changing. Tags are meant to be more permanent than branches and are a way of marking certain commits from e.g. major releases and big merges. You can't "check out" a tag and then complete work on that tag -- tags exist as anchors in the commit tree that designate certain spots.

git describe Hash

	provides how far in history the most recent tag is located.
	Output takes the form Tag_n_Hash

Social coding:
	-remote branches keep track of the state of remote repositories (since last update)
	-remote branches have a naming convention: <remote name> / <branch name>
	-if you checkout a remote branch and make a commit, the remote branch won't update to the new commit: this is because it only updates when the remote (repo) updates






##################################
## atlassian git tutorial notes ##
##################################
https://www.atlassian.com/git/tutorials

############## Learn Git

### Learn Git With Bitbucket Cloud ###

Each repo on bitbucket has a 2 GB size limit, but recommended not to exceed 1 GB (atlasoff is ~700 MB)

### Learn About Code Review In Bitbucket Cloud ###

############## Beginner

### What Is Version Control ###

### What Is Git ###

All objects in a git repo are are secured with a cryptographically secure hashing algorithm called SHA1 (protects against both accidental and malicious change and ensures that the history is fully traceable)

### Why Git For Your Organization ###

### Install Git ###



